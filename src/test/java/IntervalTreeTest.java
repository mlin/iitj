/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import static org.junit.Assert.*;

import htsjdk.samtools.util.IntervalTree;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.mlin.iitj.IntegerIntervalTree;
import org.apache.commons.math3.distribution.GeometricDistribution;
import org.apache.commons.math3.distribution.UniformIntegerDistribution;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.junit.Test;

public class IntervalTreeTest {
    @Test
    public void TestEmpty() {
        IntegerIntervalTree t = new IntegerIntervalTree.Builder().build();
        assertEquals(0, t.size());
        assertEquals(0, t.queryOverlap(Integer.MIN_VALUE, Integer.MAX_VALUE).size());
    }

    @Test
    public void RandomTest() {
        final int size = 10000;
        JDKRandomGenerator rng = new JDKRandomGenerator();
        rng.setSeed(42);
        UniformIntegerDistribution unif = new UniformIntegerDistribution(rng, 1, size);
        long totalHits = 0;
        for (int i = 0; i < size; i++) {
            totalHits += RandomTestN(unif.sample());
        }
        System.out.println(totalHits);
    }

    private long RandomTestN(final int n) {
        JDKRandomGenerator rng = new JDKRandomGenerator();
        rng.setSeed(42);
        GeometricDistribution geom = new GeometricDistribution(rng, 0.05);

        // build trees
        IntegerIntervalTree.Builder builder = new IntegerIntervalTree.Builder();
        IntervalTree<ArrayList<Integer>> control = new IntervalTree<ArrayList<Integer>>();
        for (int i = 0; i < n; i++) {
            final int len = geom.sample() + 1;
            final int beg = 10 * i - len / 2 - 5 * n;
            final int end = beg + len;

            int id = builder.add(beg, end);
            IntervalTree.Node<ArrayList<Integer>> existing = control.find(beg, end - 1);
            if (existing == null) {
                control.put(beg, end - 1, new ArrayList<Integer>());
                existing = control.find(beg, end - 1);
            }
            existing.getValue().add(id);
            if (beg % 50 == 42) {
                // spike in duplicates
                int ndup = geom.sample();
                for (int dup = 0; dup < ndup; ++dup) {
                    final int end2 = end + (i % 2 > 0 ? geom.sample() + 1 : 0);
                    id = builder.add(beg, end2);
                    existing = control.find(beg, end2 - 1);
                    if (existing == null) {
                        control.put(beg, end2 - 1, new ArrayList<Integer>());
                        existing = control.find(beg, end2 - 1);
                    }
                    existing.getValue().add(id);
                }
            }
        }

        IntegerIntervalTree expt = builder.build();
        expt.validate();

        // roundtrip our data structure through java serialization
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(bos);
            out.writeObject(expt);
            out.close();
            byte[] ser = bos.toByteArray();

            ByteArrayInputStream bis = new ByteArrayInputStream(ser);
            expt = (IntegerIntervalTree) (new ObjectInputStream(bis)).readObject();
        } catch (Exception exc) {
            assertTrue(false);
        }
        expt.validate();

        // run queries and test equivalence. place extra focus on the far right of the tree, since
        // this is where most of the corner cases arise
        UniformIntegerDistribution unif = new UniformIntegerDistribution(rng, 0 - 5 * n, 5 * n);
        UniformIntegerDistribution unif2 = new UniformIntegerDistribution(rng, 5 * n - 256, 5 * n);
        long totalHits = 0;
        for (int i = 0; i < n; i++) {
            int queryBeg = (i % 4 == 1) ? unif.sample() : unif2.sample();
            int queryEnd = queryBeg + geom.sample() + 1;

            ArrayList<IntegerIntervalTree.QueryResult> controlHits =
                    new ArrayList<IntegerIntervalTree.QueryResult>();
            for (Iterator<IntervalTree.Node<ArrayList<Integer>>> it =
                            control.overlappers(queryBeg, queryEnd - 1);
                    it.hasNext(); ) {
                IntervalTree.Node<ArrayList<Integer>> hit = it.next();
                for (Integer v : hit.getValue()) {
                    controlHits.add(
                            new IntegerIntervalTree.QueryResult(
                                    hit.getStart(), hit.getEnd() + 1, v));
                }
            }

            assertEquals(expt.queryOverlapExists(queryBeg, queryEnd), !controlHits.isEmpty());
            List<IntegerIntervalTree.QueryResult> hits = expt.queryOverlap(queryBeg, queryEnd);
            assertEquals(controlHits, hits);
            totalHits += hits.size();
        }

        // test exact query
        for (Iterator<IntervalTree.Node<ArrayList<Integer>>> it = control.iterator();
                it.hasNext(); ) {
            IntervalTree.Node<ArrayList<Integer>> node = it.next();
            ArrayList<Integer> results = new ArrayList<Integer>();
            expt.queryExactId(
                    node.getStart(),
                    node.getEnd() + 1,
                    i -> {
                        results.add(i);
                        return true;
                    });
            assertEquals(node.getValue(), results);
        }

        return totalHits;
    }
}
