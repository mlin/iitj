/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import static org.junit.Assert.*;

import htsjdk.samtools.util.IntervalTree;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.mlin.iitj.IntegerIntervalTree;
import org.apache.commons.math3.distribution.GeometricDistribution;
import org.apache.commons.math3.distribution.UniformIntegerDistribution;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.junit.Test;

public class IntervalTreeTest {
    @Test
    public void TestEmpty() {
        IntegerIntervalTree t = new IntegerIntervalTree.Builder().build();
        assertEquals(0, t.size());
        assertEquals(0, t.queryOverlap(Integer.MIN_VALUE, Integer.MAX_VALUE).size());
    }

    @Test
    public void RandomTest() {
        final int size = 10000;
        JDKRandomGenerator rng = new JDKRandomGenerator();
        rng.setSeed(42);
        UniformIntegerDistribution unif = new UniformIntegerDistribution(rng, 1, size);
        for (int i = 0; i < size; i++) {
            RandomTestN(unif.sample());
        }
    }

    private void RandomTestN(final int n) {
        JDKRandomGenerator rng = new JDKRandomGenerator();
        rng.setSeed(42);
        GeometricDistribution geom = new GeometricDistribution(rng, 0.05);

        IntegerIntervalTree.Builder builder = new IntegerIntervalTree.Builder();
        IntervalTree<ArrayList<Integer>> control = new IntervalTree<ArrayList<Integer>>();

        for (int i = 0; i < n; i++) {
            int len = geom.sample() + 1;
            int beg = 10 * i - len / 2 - 5 * n;
            int end = beg + len;

            IntervalTree.Node<ArrayList<Integer>> existing = control.find(beg, end - 1);
            if (existing == null) {
                control.put(beg, end - 1, new ArrayList<Integer>());
                existing = control.find(beg, end - 1);
            }
            existing.getValue().add(i);
            builder.add(beg, end, i);
            if (beg % 10 == 3) {
                // spike in duplicates
                existing.getValue().add(i);
                builder.add(beg, end, i);
            }
        }

        IntegerIntervalTree expt = builder.build();
        expt.validate();

        UniformIntegerDistribution unif = new UniformIntegerDistribution(rng, 0 - 5 * n, 5 * n);
        for (int i = 0; i < n; i++) {
            int queryBeg = unif.sample();
            int queryEnd = queryBeg + geom.sample() + 1;

            ArrayList<IntegerIntervalTree.QueryResult> controlHits =
                    new ArrayList<IntegerIntervalTree.QueryResult>();
            for (Iterator<IntervalTree.Node<ArrayList<Integer>>> it =
                            control.overlappers(queryBeg, queryEnd - 1);
                    it.hasNext(); ) {
                IntervalTree.Node<ArrayList<Integer>> hit = it.next();
                for (Integer v : hit.getValue()) {
                    controlHits.add(
                            new IntegerIntervalTree.QueryResult(
                                    hit.getStart(), hit.getEnd() + 1, v));
                }
            }

            List<IntegerIntervalTree.QueryResult> hits = expt.queryOverlap(queryBeg, queryEnd);
            assertEquals(
                    (new IntegerIntervalTree.QueryResult(queryBeg, queryEnd, null)).toString(),
                    controlHits,
                    hits);
        }
    }
}
